// 有一个数组a[N] 顺序存放0~N - 1， 要求每隔两个数删掉一个数， 到末尾时循环至开头继续进行， 求最后一个被删掉的数的原始下标位置。 以8个数(N = 7) 为例: 
// ｛0， 1， 2， 3， 4， 5， 6， 7｝， 0 - > 1 - > 2(删除) - > 3 - > 4 - > 5(删除) - > 6 - > 7 - > 0(删除), 如此循环直到最后一个数被删除。
// 输入描述:
//   每组数据为一行一个整数n(小于等于1000)， 为数组成员数, 如果大于1000， 则对a[999] 进行计算。
// 输出描述:
//   一行输出最后一个被删掉的数的原始下标位置。
// 输入例子1:
//   8
// 输出例子1:
//   6
let data = parseInt(readline())
while (data) {
  let ret = josephRing(data, 3)
  console.log(ret)
  data = parseInt(readline())
}

function josephRing(n, m) {
  let arr = new Array(n); //长度为n的数组，位置从0——n-1，就代表了 n 个人的编号
  let count = 0; //纪录出圈人数
  let num = 0; //报数器
  for (let i = 0; i < arr.length; i++) { //将数组所有元素设定为 1
    arr[i] = 1;
  }

  //设定循环结束条件：当 count = n-1 时，游戏结束
  while (count < n - 1) {
    for (let i = 0; i < arr.length; i++) { //第二层循环，循环数组 
      if (arr[i] === 1) { //当这个位置的元素为 1 时，就执行接下来的代码
        num++; //每经过一个元素为 1 的位置时，就让报数器加 1 
        if (num === m) { //当报数器等于 m 时，就执行接下来的代码 
          arr[i] = 0; //让这个位置的元素为 0，表示这个位置已经出圈了
          count++; //纪录出圈人数的变量加 1
          num = 0; //将报数器清零
        }
        //当 m = 1 时，只有当 count = n 才会退出第二层循环（for循环），for 循环只需循环一次，数组内的所有元素都变为了 0，为了避免这个问题，必须要有这个 if 判断句，达到特定条件时强制退出
        //其实当 m = 1时，结果就是 n，也可以将 m = 1 作为特殊情况来处理，即写在 while 循环以外，如此 m = 1 时就不会进入循环 
        if (count === n - 1) {
          break
        }
      }
    }
  }
  //循环数组，找到元素为 1 的位置，将这个位置输出
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === 1) {
      return i
    }
  }
}